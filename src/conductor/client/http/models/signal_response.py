import pprint
import re  # noqa: F401
import six
from dataclasses import dataclass, field, InitVar, asdict
from typing import Dict, Any, Optional, List
from enum import Enum


class WorkflowSignalReturnStrategy(Enum):
    """Enum for workflow signal return strategy"""
    TARGET_WORKFLOW = "TARGET_WORKFLOW"
    BLOCKING_WORKFLOW = "BLOCKING_WORKFLOW"
    BLOCKING_TASK = "BLOCKING_TASK"
    BLOCKING_TASK_INPUT = "BLOCKING_TASK_INPUT"


class TaskStatus(Enum):
    """Enum for task status"""
    IN_PROGRESS = "IN_PROGRESS"
    CANCELED = "CANCELED"
    FAILED = "FAILED"
    FAILED_WITH_TERMINAL_ERROR = "FAILED_WITH_TERMINAL_ERROR"
    COMPLETED = "COMPLETED"
    COMPLETED_WITH_ERRORS = "COMPLETED_WITH_ERRORS"
    SCHEDULED = "SCHEDULED"
    TIMED_OUT = "TIMED_OUT"
    READY_FOR_RERUN = "READY_FOR_RERUN"
    SKIPPED = "SKIPPED"


@dataclass
class SignalResponse:
    """Merged SignalResponse class containing both signal and task run fields.

    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    # Signal Response fields
    _response_type: Optional[str] = field(default=None, init=False)
    _target_workflow_id: Optional[str] = field(default=None, init=False)
    _target_workflow_status: Optional[str] = field(default=None, init=False)
    _request_id: Optional[str] = field(default=None, init=False)
    _workflow_id: Optional[str] = field(default=None, init=False)
    _correlation_id: Optional[str] = field(default=None, init=False)
    _input: Optional[Dict[str, Any]] = field(default=None, init=False)
    _output: Optional[Dict[str, Any]] = field(default=None, init=False)

    # Task Run fields
    _task_type: Optional[str] = field(default=None, init=False)
    _task_id: Optional[str] = field(default=None, init=False)
    _reference_task_name: Optional[str] = field(default=None, init=False)
    _retry_count: int = field(default=0, init=False)
    _task_def_name: Optional[str] = field(default=None, init=False)
    _retried_task_id: Optional[str] = field(default=None, init=False)
    _workflow_type: Optional[str] = field(default=None, init=False)
    _reason_for_incompletion: Optional[str] = field(default=None, init=False)
    _priority: int = field(default=0, init=False)
    _variables: Optional[Dict[str, Any]] = field(default=None, init=False)
    _tasks: Optional[List[Any]] = field(default=None, init=False)
    _created_by: Optional[str] = field(default=None, init=False)
    _create_time: int = field(default=0, init=False)
    _update_time: int = field(default=0, init=False)
    _status: Optional[TaskStatus] = field(default=None, init=False)

    # InitVar fields for initialization
    response_type: InitVar[Optional[str]] = None
    target_workflow_id: InitVar[Optional[str]] = None
    target_workflow_status: InitVar[Optional[str]] = None
    request_id: InitVar[Optional[str]] = None
    workflow_id: InitVar[Optional[str]] = None
    correlation_id: InitVar[Optional[str]] = None
    input: InitVar[Optional[Dict[str, Any]]] = None
    output: InitVar[Optional[Dict[str, Any]]] = None
    task_type: InitVar[Optional[str]] = None
    task_id: InitVar[Optional[str]] = None
    reference_task_name: InitVar[Optional[str]] = None
    retry_count: InitVar[int] = 0
    task_def_name: InitVar[Optional[str]] = None
    retried_task_id: InitVar[Optional[str]] = None
    workflow_type: InitVar[Optional[str]] = None
    reason_for_incompletion: InitVar[Optional[str]] = None
    priority: InitVar[int] = 0
    variables: InitVar[Optional[Dict[str, Any]]] = None
    tasks: InitVar[Optional[List[Any]]] = None
    created_by: InitVar[Optional[str]] = None
    create_time: InitVar[int] = 0
    update_time: InitVar[int] = 0
    status: InitVar[Optional[TaskStatus]] = None

    swagger_types = {
        'response_type': 'str',
        'target_workflow_id': 'str',
        'target_workflow_status': 'str',
        'request_id': 'str',
        'workflow_id': 'str',
        'correlation_id': 'str',
        'input': 'dict(str, object)',
        'output': 'dict(str, object)',
        'task_type': 'str',
        'task_id': 'str',
        'reference_task_name': 'str',
        'retry_count': 'int',
        'task_def_name': 'str',
        'retried_task_id': 'str',
        'workflow_type': 'str',
        'reason_for_incompletion': 'str',
        'priority': 'int',
        'variables': 'dict(str, object)',
        'tasks': 'list[object]',
        'created_by': 'str',
        'create_time': 'int',
        'update_time': 'int',
        'status': 'str'
    }

    attribute_map = {
        'response_type': 'responseType',
        'target_workflow_id': 'targetWorkflowId',
        'target_workflow_status': 'targetWorkflowStatus',
        'request_id': 'requestId',
        'workflow_id': 'workflowId',
        'correlation_id': 'correlationId',
        'input': 'input',
        'output': 'output',
        'task_type': 'taskType',
        'task_id': 'taskId',
        'reference_task_name': 'referenceTaskName',
        'retry_count': 'retryCount',
        'task_def_name': 'taskDefName',
        'retried_task_id': 'retriedTaskId',
        'workflow_type': 'workflowType',
        'reason_for_incompletion': 'reasonForIncompletion',
        'priority': 'priority',
        'variables': 'variables',
        'tasks': 'tasks',
        'created_by': 'createdBy',
        'create_time': 'createTime',
        'update_time': 'updateTime',
        'status': 'status'
    }

    def __post_init__(self, response_type, target_workflow_id, target_workflow_status, request_id,
                      workflow_id, correlation_id, input, output, task_type, task_id,
                      reference_task_name, retry_count, task_def_name, retried_task_id,
                      workflow_type, reason_for_incompletion, priority, variables, tasks,
                      created_by, create_time, update_time, status):
        # Signal Response fields
        if response_type is not None:
            self.response_type = response_type
        if target_workflow_id is not None:
            self.target_workflow_id = target_workflow_id
        if target_workflow_status is not None:
            self.target_workflow_status = target_workflow_status
        if request_id is not None:
            self.request_id = request_id
        if workflow_id is not None:
            self.workflow_id = workflow_id
        if correlation_id is not None:
            self.correlation_id = correlation_id
        if input is not None:
            self.input = input
        if output is not None:
            self.output = output

        # Task Run fields
        if task_type is not None:
            self.task_type = task_type
        if task_id is not None:
            self.task_id = task_id
        if reference_task_name is not None:
            self.reference_task_name = reference_task_name
        self.retry_count = retry_count
        if task_def_name is not None:
            self.task_def_name = task_def_name
        if retried_task_id is not None:
            self.retried_task_id = retried_task_id
        if workflow_type is not None:
            self.workflow_type = workflow_type
        if reason_for_incompletion is not None:
            self.reason_for_incompletion = reason_for_incompletion
        self.priority = priority
        if variables is not None:
            self.variables = variables
        if tasks is not None:
            self.tasks = tasks
        if created_by is not None:
            self.created_by = created_by
        self.create_time = create_time
        self.update_time = update_time
        if status is not None:
            self.status = status

        self.discriminator = None

    # Signal Response Properties
    @property
    def response_type(self):
        return self._response_type

    @response_type.setter
    def response_type(self, response_type):
        allowed_values = ["TARGET_WORKFLOW", "BLOCKING_WORKFLOW", "BLOCKING_TASK", "BLOCKING_TASK_INPUT"]
        if response_type is not None and response_type not in allowed_values:
            raise ValueError(
                "Invalid value for `response_type` ({0}), must be one of {1}"
                .format(response_type, allowed_values)
            )
        self._response_type = response_type

    @property
    def target_workflow_id(self):
        return self._target_workflow_id

    @target_workflow_id.setter
    def target_workflow_id(self, target_workflow_id):
        self._target_workflow_id = target_workflow_id

    @property
    def target_workflow_status(self):
        return self._target_workflow_status

    @target_workflow_status.setter
    def target_workflow_status(self, target_workflow_status):
        allowed_values = ["RUNNING", "COMPLETED", "FAILED", "TIMED_OUT", "TERMINATED", "PAUSED"]
        if target_workflow_status is not None and target_workflow_status not in allowed_values:
            raise ValueError(
                "Invalid value for `target_workflow_status` ({0}), must be one of {1}"
                .format(target_workflow_status, allowed_values)
            )
        self._target_workflow_status = target_workflow_status

    @property
    def request_id(self):
        return self._request_id

    @request_id.setter
    def request_id(self, request_id):
        self._request_id = request_id

    @property
    def workflow_id(self):
        return self._workflow_id

    @workflow_id.setter
    def workflow_id(self, workflow_id):
        self._workflow_id = workflow_id

    @property
    def correlation_id(self):
        return self._correlation_id

    @correlation_id.setter
    def correlation_id(self, correlation_id):
        self._correlation_id = correlation_id

    @property
    def input(self):
        return self._input

    @input.setter
    def input(self, input):
        self._input = input

    @property
    def output(self):
        return self._output

    @output.setter
    def output(self, output):
        self._output = output

    # Task Run Properties
    @property
    def task_type(self):
        return self._task_type

    @task_type.setter
    def task_type(self, task_type):
        self._task_type = task_type

    @property
    def task_id(self):
        return self._task_id

    @task_id.setter
    def task_id(self, task_id):
        self._task_id = task_id

    @property
    def reference_task_name(self):
        return self._reference_task_name

    @reference_task_name.setter
    def reference_task_name(self, reference_task_name):
        self._reference_task_name = reference_task_name

    @property
    def retry_count(self):
        return self._retry_count

    @retry_count.setter
    def retry_count(self, retry_count):
        self._retry_count = retry_count

    @property
    def task_def_name(self):
        return self._task_def_name

    @task_def_name.setter
    def task_def_name(self, task_def_name):
        self._task_def_name = task_def_name

    @property
    def retried_task_id(self):
        return self._retried_task_id

    @retried_task_id.setter
    def retried_task_id(self, retried_task_id):
        self._retried_task_id = retried_task_id

    @property
    def workflow_type(self):
        return self._workflow_type

    @workflow_type.setter
    def workflow_type(self, workflow_type):
        self._workflow_type = workflow_type

    @property
    def reason_for_incompletion(self):
        return self._reason_for_incompletion

    @reason_for_incompletion.setter
    def reason_for_incompletion(self, reason_for_incompletion):
        self._reason_for_incompletion = reason_for_incompletion

    @property
    def priority(self):
        return self._priority

    @priority.setter
    def priority(self, priority):
        self._priority = priority

    @property
    def variables(self):
        return self._variables

    @variables.setter
    def variables(self, variables):
        self._variables = variables

    @property
    def tasks(self):
        return self._tasks

    @tasks.setter
    def tasks(self, tasks):
        self._tasks = tasks

    @property
    def created_by(self):
        return self._created_by

    @created_by.setter
    def created_by(self, created_by):
        self._created_by = created_by

    @property
    def create_time(self):
        return self._create_time

    @create_time.setter
    def create_time(self, create_time):
        self._create_time = create_time

    @property
    def update_time(self):
        return self._update_time

    @update_time.setter
    def update_time(self, update_time):
        self._update_time = update_time

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, status):
        self._status = status

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            try:
                # Get the actual property value by accessing the private attribute
                # or calling the property getter
                if hasattr(self, f'_{attr}'):
                    # Access the private attribute directly to get the actual value
                    value = getattr(self, f'_{attr}')
                else:
                    # Fallback to the property getter
                    value = getattr(self, attr)

                # Skip None values and property objects
                if value is None or isinstance(value, property):
                    continue

                if isinstance(value, list):
                    result[attr] = list(map(
                        lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                        value
                    ))
                elif hasattr(value, "to_dict"):
                    result[attr] = value.to_dict()
                elif isinstance(value, dict):
                    result[attr] = dict(map(
                        lambda item: (item[0], item[1].to_dict())
                        if hasattr(item[1], "to_dict") else item,
                        value.items()
                    ))
                elif isinstance(value, TaskStatus):
                    result[attr] = value.value
                else:
                    result[attr] = value

            except (AttributeError, TypeError):
                # Skip attributes that can't be accessed
                continue

        # Convert to camelCase using attribute_map
        camel_case_result = {}
        for snake_key, camel_key in self.attribute_map.items():
            if snake_key in result and result[snake_key] is not None:
                camel_case_result[camel_key] = result[snake_key]

        if issubclass(SignalResponse, dict):
            for key, value in self.items():
                camel_case_result[key] = value

        return camel_case_result

    # Alternative approach - override __str__ for better printing
    def __str__(self):
        """Returns a more readable string representation"""
        return f"""SignalResponse(
        response_type='{self.response_type}',
        target_workflow_id='{self.target_workflow_id}',
        target_workflow_status='{self.target_workflow_status}',
        workflow_id='{self.workflow_id}',
        task_id='{self.task_id}',
        task_type='{self.task_type}',
        status='{self.status}',
        reference_task_name='{self.reference_task_name}',
        retry_count={self.retry_count},
        input={self.input},
        output={self.output}
    )"""

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SignalResponse':
        """Create instance from dictionary with camelCase keys"""
        snake_case_data = {}

        # Reverse mapping from camelCase to snake_case
        reverse_mapping = {v: k for k, v in cls.attribute_map.items()}

        for camel_key, value in data.items():
            if camel_key in reverse_mapping:
                snake_key = reverse_mapping[camel_key]
                if snake_key == 'status' and value:
                    snake_case_data[snake_key] = TaskStatus(value)
                else:
                    snake_case_data[snake_key] = value

        return cls(**snake_case_data)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SignalResponse):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other